upside of operatives being curried: modules are just partially applied `let`s

interactive programming checklist:
- You need to be able to easily redefine most things.
    For example, CL and Smalltalk both have hooks for updating instances of a
    class when the class itself changes. Python fails in this regard because if
    you e.g. import a function in more than one module, it becomes very
    challenging to redefine the function in all places. Even just reloading a
    single module in a single place is recommended against (though that is
    relatively easy to do).
- Define a datatype. I mean a class, a struct, a record type–whatever
    user-defined type your favorite language supports. Make some instances of
    it. Write some functions (or methods, or procedures, or whatever) to operate
    on them. Now change the definition of the type. What happens? Does your
    language runtime notice that the definition of the type has changed? Does it
    realize that the existing instances have a new definition? When something
    touches one of them, does it automatically reinitialize it to conform to the
    new definition, or, if it doesn’t know how to do that, does it start a
    breakloop and ask you what to do about it?
- You don’t want to have to kill your program and rebuild it from scratch just
    because you changed a definition

---
A note for tree calculus:

Barry Jay (the author) claims it works using just one ternary operator (called
delta, or Δ) with three rewrite rules:
    ΔΔyz = y
 Δ(Δx)yz = yz(xz)
Δ(Δwx)yz = zwx

However, when I tried to translate it to INets, I had to reformulate the system.
In my variation, tree calculus is a system of four operators: K, S, F (when
delta is applied to 0, 1 or 2 arguments, respectively), and @ (which is the
application operator). The arities for the operators K, S, F and @ are 0, 1, 2
and 2, respectively. The rules are then:

@Kx = Sx
@(Sx)y = Fxy

(The original reduction rules, reformulated:)
@(FKy)z = y
@(F(Sx)y)z = @(@yz)(@xz)
@(F(Fwx)y)z = @(@zw)x

However, to translate to interaction nets, the depth of the left-hand side of
the rules can't exceed two, so they have to be rearranged, and a new symbol #
with arity 3 has to be introduced:

@Kx = Sx
@(Sx)y = Fxy
@(Fxy)z = #xyz
#Kyz = y
#(Sx)yz = @(@yz)(@xz)
#(Fwx)yz = @(@zw)x

---
Side effects

print: prints the arg
rand: takes an arg N, returns a random number between 0 and N
encode `print(rand(5))`

an effect is a function (arg, resource) -> (return value, another resource)
resources cannot be copied, therefore resources cannot be first-class values
